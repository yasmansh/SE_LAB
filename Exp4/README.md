<div dir=”rtl”>
  
  ## گزارش آزمایش:
  
ابتدا دو فایل hamcrest و junit رو به libraries اضافه می کنیم.
  
  برای وارد شدن به این بخش هم در محیط intelij کلیدهای ctrl + alt + s را فشار می دهیم.

  
<p align="center">
<img src="https://github.com/yasmansh/SE_LAB/blob/main/Exp4/pics/pic1.JPG" height="600">
</p>

  در گام اول تست ها را آماده می کنیم.
  
  کد تست محاسبه مساحت
 
<p align="center">
<img src="https://github.com/yasmansh/SE_LAB/blob/main/Exp4/pics/pic2.JPG" height="600">
</p>


  حال کد مستطیل را می زنیم 
<p align="center">
<img src="https://github.com/yasmansh/SE_LAB/blob/main/Exp4/pics/pic4.JPG" height="600">
</p>
  
سپس مقدار تست را تغییر می دهیم تا مقدار جواب غلط باشد و صرفا ببینیم هنگام فرق داشتن جواب چه اتفاقی رخ می دهد.
  
  <p align="center">
<img src="https://github.com/yasmansh/SE_LAB/blob/main/Exp4/pics/pic3.JPG" height="600">
</p>
  
 حال تست های مستطیل را کامل تر می کنیم و set و get را هم اضافه می کنیم.
  
  <p align="center">
<img src="https://github.com/yasmansh/SE_LAB/blob/main/Exp4/pics/pic5.JPG" height="600">
</p>
  
  سپس کد مربوط به مستطیل را کامل می کنیم و get و set را اضافه می کنیم.
  
  <p align="center">
<img src="https://github.com/yasmansh/SE_LAB/blob/main/Exp4/pics/pic8.JPG" height="600">
</p>
  
 حال دوباره تست می کنیم و از قصد مقدار تست را غلط می دهیم تا ببینیم ارور به چه شکل رخ می دهد.
  
  <p align="center">
<img src="https://github.com/yasmansh/SE_LAB/blob/main/Exp4/pics/pic7.JPG" height="600">
</p>
  
  حال کد تست مربع را می زنیم.
  
  <p align="center">
<img src="https://github.com/yasmansh/SE_LAB/blob/main/Exp4/pics/pic10.JPG" height="600">
</p>
  
  سپس کد مربع را می زنیم.
  
  <p align="center">
<img src="https://github.com/yasmansh/SE_LAB/blob/main/Exp4/pics/pic9.JPG" height="600">
</p>
  
  اما کد ها را می توان کامل تر کرد به این شکل که در تابع cunstructor هم از متد set استفاده کرد.
  
  <p align="center">
<img src="https://github.com/yasmansh/SE_LAB/blob/main/Exp4/pics/pic11.JPG" height="600">
</p>
  
<p align="center">
<img src="https://github.com/yasmansh/SE_LAB/blob/main/Exp4/pics/pic12.JPG" height="600">
</p>
  
  حال برای رعایت کردن تمام اصول یک interface به اسم computer اضافه می کنیم که متد computeArea را برای هر دو کلاس در آن قرار می دهیم و در هر دو کلاس آن را implement می کنیم.
  
  <p align="center">
<img src="https://github.com/yasmansh/SE_LAB/blob/main/Exp4/pics/pic13.JPG" height="600">
</p>
  
<p align="center">
<img src="https://github.com/yasmansh/SE_LAB/blob/main/Exp4/pics/pic14.JPG" height="600">
</p>

 
 دلایل رعایت شدن اصول SOLID:
  اصل اول (Principle Responsibility Single): این اصل برقرار است. زیرا هر کدام از کلاس های مستطیل و مربع فقط یک کار انجام می دهند و کار ساخت مستطیل یا مربع توسط یک کلاس انجام نمی شود.
  
  اصل دوم (Open/Close): 
  با توجه به این موضوع که هر دو کلاس نسبت به تغییرات بسته هستند و اگر بخواهیم ویژگی جدیدی به آن ها اضافه کنیم نیازی نیست تا در بقیه کد تغییری به وجود بیاوریم.
  
  اصل سوم (Liskov):
  اگر interface مان را به عنوان کلاس پدر در نظر بگیریم، آن گاه هر دو کلاس مربع یا مستطیل قابلیت جایگزینی دارند. همچنین برای هر دو کلاس مربع و مستطیل اگر زیر کلاس بسازیم مشکلی پیش نمیاید. 
  
  اصل چهارم (interface segragation):
  چون یک interface داریم رعایت شده است و کلا باید interface ها جدا باشند.
  
  اصل پنجم (dependency inversion):
چون کلاس های ما از هم ارث بری نکرده اند و متد مشترکشان در interface است هم این اصل رعایت شده است.
  
  
  
   ## پرسش‌ها
 ### 1. هریک از 5 اصل solid را در دو الی سه خط توضیح دهید.
 
اصل Single-Responsibility:
یک کلاس باید یک و فقط یک دلیل برای تغییر داشته باشد، درواقع یک کلاس فقط به یک actor باید جواب بدهد. از نظر فنی، یک تغییر بالقوه (منطق پایگاه داده، منطق ورود به سیستم و ...) در مشخصات نرم افزار باید بتواند بر مشخصات کلاس تأثیر بگذارد.

اصل  Open–closed:
اشیا یا موجودیت ها باید برای گسترش و افزونه باز باشند اما برای اصلاح بسته باشند.
اصلاح به معنای تغییر کد یک کلاس موجود است و افزونه به معنای افزودن عملکرد جدید است. درواقع ما باید بتوانیم قابلیت‌های جدیدی را بدون دست زدن به کدهای موجود برای کلاس اضافه کنیم. این به این دلیل است که هر زمان که کد موجود را اصلاح می کنیم، خطر ایجاد اشکالات احتمالی را می پذیریم. 

اصل Liskov substitution:
اصل جایگزینی لیسکوف بیان می کند که کلاس های فرعی باید برای کلاس های پایه خود جایگزین شوند.
یعنی کلاس فرزند بتواند جایگزین کلاس پدر شود. طبق این، وقتی از وراثت استفاده می‌کنیم، فرض می‌کنیم که کلاس فرزند هر چیزی را که سوپرکلاس دارد به ارث می‌برد. کلاس کودک رفتار را گسترش می دهد اما هرگز آن را محدود نمی کند.

اصل  Interface segregation :
مشتری یا کلاینت هرگز نباید مجبور به پیاده سازی رابطی شود که از آن استفاده نمی کند، یا کلاینت ها نباید مجبور شوند به روش هایی که استفاده نمی کنند وابسته باشند.

اصل  Dependency inversion:
این اصل بیان می‌کند که کلاس‌های ما باید به جای کلاس‌ها و توابع مشخص، به رابط‌ها یا کلاس‌های انتزاعی وابسته باشند. درواقع موجودیت ها باید به انتزاعات وابسته باشند، نه به ادغام. طبق این اصل، ماژول سطح بالا نباید به ماژول سطح پایین بستگی داشته باشد، اما آنها باید به انتزاعات وابسته باشند.
این اصل امکان جداسازی را فراهم می کند.
 
 ### 2.  اصول solid در کدام یک از گام های نرم افزار (تحلیل نیازمندی‌ها، طراحی،پیاده سازی، تست و استقرار استفاده می شوند؟ توضیح دهید.)
 
 این روش یکی از روش های طراحی نرم افزار محسوب شده و در فاز پیاده سازی نیز باید به اصول آن مقید باشیم.
 
 ### 3. معمولاً گام تست در پایان روند ایجاد نرم افزار انجام می شود، اما در روش TDD تست‌نویسی پیش از پیاده سازی شروع می شود. آیا این دو مورد با هم تناقضی دارند؟ توضیح دهید.
 
 خیر. زیرا در عمل این تست ها درجهت پیاده سازی به کار رفته و توسعه‌دهندگان قبل از نوشتن کد موردنیاز، یک تست می‌نویسند. توسعه دهندگان از مشخصات استفاده می کنند و ابتدا تستی را می نویسند که توضیح می دهد چگونه باید رفتار کرد. تکرار این کار، یک چرخه سریع از آزمایش، کدگذاری، و refactoring است. درواقع این، یک فرآیند توسعه نرم‌افزار است
 
 ### 4.فرض کنید در آزمایش بالا نیازی به تغییر ابعاد مستطیل نداشتیم. در این حالت طراحی مدل ها چه تفاوتی می کند؟
</div>
